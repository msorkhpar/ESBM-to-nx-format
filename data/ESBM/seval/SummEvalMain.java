package edu.nju.ws.seval;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.apache.jena.graph.Triple;
import org.apache.jena.riot.Lang;
import org.apache.jena.riot.RDFParser;
import org.apache.jena.riot.lang.PipedRDFIterator;
import org.apache.jena.riot.lang.PipedRDFStream;
import org.apache.jena.riot.lang.PipedTriplesStream;

import edu.nju.ws.seval.utils.AlgoMeasures;
import edu.nju.ws.seval.utils.ThreeTuple;

/**
 * modified from esummeval_v1.1:
 * 1. add ds+"_data" to read desc/gold files;
 * 2. add "rank_"+topK to read tunned rank results;
 * 3. change MAP to NDCG (graded). 
 * @author qxliu Jul 27, 2017 10:31:24 AM
 *
 */
public class SummEvalMain {
	/**
	 * path of the directory of benchmark data, e.g. "..../ESEM_benchmark/" 
	 */
		public static String benchmarkDir = "ESBM_benchmark";//default value (when under the same folder with benchmark)
	/**
	 * path of the directory of summaries generated by your system, e.g. "..../summ_example/" 
	 */
		public static String algosummDir = "summ_example";//default value (when under the same folder with algorithm generated summaries)
	
	public static enum Topk{top5,top10}; 
	public static enum Dataset{dbpedia, lmdb};
	public static final HashMap<Dataset, Integer> eNumMap = new HashMap<>();
	static{
		eNumMap.put(Dataset.dbpedia, 125);
		eNumMap.put(Dataset.lmdb, 50);
	}
//	static{
//		eNumMap.put(Dataset.dbpedia, 100);
//		eNumMap.put(Dataset.lmdb, 40);
//	}
	/**
	 * 
	 * @param args
	 * @author qxliu Jul 30, 2017 10:31:38 PM
	 */
	public static void main(String[] args) {
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2/summ_example/"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/relin"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2", "D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/diversum"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2", "D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/faces"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/faces_e"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2", "D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/cd"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/linksum"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/bafrec"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/kafca"};
//		args=new String[]{"D:/work/runspace/eSumm/v1.2/ESBM_benchmark_v1.2/","D:/work/runspace/eSumm/v1.2_prepare/runs_trainValid2/mpsum"};
		//1. get params from user input or use default values
		if(args.length>=2){
			benchmarkDir = args[0];
			algosummDir = args[1];
		}
		boolean showDir = true;
		if(args.length>2){
			try{
				showDir = ((String)args[2]).equals("false")?false:true;
			}catch(Exception e){
				System.out.println("Please input two arguments: \n 1. path of the directory of benchmark files ; \n 2. path of the directory of generated summaries (output files of your system)");
				System.exit(0); //====
			}
		}
		
		
		//2. check existence of data
		File benchDir = new File(benchmarkDir);
		File algoDir = new File(algosummDir);
//		System.out.println(!benchDir.exists()+"|"+algoDir.getAbsolutePath()+"|"+algosummDir +"|"+ !algoDir.exists()+"|"+(!benchDir.isDirectory() || !algoDir.isDirectory()));
		if(!benchDir.exists() || !algoDir.exists()
				||!benchDir.isDirectory() || !algoDir.isDirectory() ){
			System.err.println("Directory not exist!");
			System.out.println("Please input two arguments: \n 1. path of the directory of benchmark files ; \n 2. path of the directory of generated summaries (output files of your system)");
			System.exit(0); //====
		}
		//3. run the evaluator
		System.out.println("\n******************************************");
		if(showDir) {
			System.out.println("Evaluating with settings:");
			System.out.println(" benchmark directory: "+benchDir.getAbsolutePath()+"\n summarizer output directory: "+algoDir.getAbsolutePath());
		}else{
			System.out.println("Evaluation results:");
		}
		System.out.println();
		Map<Topk, ThreeTuple<double[], Integer, Integer>> scoreForAllMap = new HashMap<>();//<topk, (score, eFCountAll, eMCountAll)
		int eNumAll = 0;
		for(Dataset ds: Dataset.values()){
			File dsFile = new File(benchDir.getAbsolutePath()+"/"+ds+"_data");
			System.out.println("dsFile:"+dsFile.exists()+"\t"+dsFile.getAbsolutePath());
			if(dsFile.exists() && dsFile.isDirectory()){
				System.out.println("=================\nDataset: "+ds);
				int eNum = eNumMap.get(ds);
				eNumAll+=eNum;
				for(Topk topk : Topk.values()){
					
					ThreeTuple<double[], Integer, Integer> results = getScores(topk, ds);
					double[] avgPRFG = results.getFirst();
					int eFCount = results.getSecond();
					int eGCount = results.getThird();
					
					if(eFCount!=eNum || eGCount!=eNum){
						System.out.println("Warning: Not all "+eNum+" entities have output files! xx_"+topk+".nt from "+eFCount+" entities , xx_rank.nt from "+eGCount+" entities.");
					}
					System.out.println("Results("+ds+"@"+topk+"):\tF-measure="+(eFCount>0?avgPRFG[2]:null)+", NDCG="+(eGCount>0?avgPRFG[3]:null));//for v1.2
//					System.out.println("Results("+ds+"@"+topk+"):\tF-measure="+(eFCount>0?avgPRFM[2]:null)+", MAP="+(eMCount>0?avgPRFM[3]:null));//for v1.1
//					System.out.println("Results("+ds+"@"+topk+"):\tF-measure="+avgPRFM[2]+", MAP="+avgPRFM[3]);
					
					// prepare for all
					ThreeTuple<double[], Integer, Integer> topkInfo = scoreForAllMap.get(topk);
					if(topkInfo==null){//init
						double[] scoreForAll = new double[4];
						for(int i=0; i<4; i++) scoreForAll[i]=0;
						topkInfo = new ThreeTuple<double[], Integer, Integer>(scoreForAll, 0, 0);
					}
					double[] scoreForAll = topkInfo.getFirst();
					for(int i=0; i<4; i++) scoreForAll[i]+=avgPRFG[i]*eNum;
					topkInfo.setSecond(topkInfo.getSecond()+eFCount);
					topkInfo.setThird(topkInfo.getThird()+eGCount);
					scoreForAllMap.put(topk, topkInfo);
				}//end topk
			}
		}//end ds	

		System.out.println("=================\nFor all "+eNumAll+" entities: ");
		for(Topk topk : Topk.values()){
			ThreeTuple<double[], Integer, Integer> topkInfo = scoreForAllMap.get(topk);
			double[] scoreForAll = topkInfo.getFirst();
			for(int i=0; i<4; i++) {
				scoreForAll[i]/=eNumAll;
			}
			int eFCountAll = topkInfo.getSecond();
			int eGCountAll = topkInfo.getThird();
			if(eFCountAll!=eNumAll || eGCountAll!=eNumAll){
				System.out.println("Warning: Not all "+eNumAll+" entities have output files! xx_"+topk+".nt from "+eFCountAll+" entities , xx_rank.nt from "+eGCountAll+" entities.");
			}
			System.out.println("Results(all@"+topk+"):\tF-measure="+(eFCountAll>0?scoreForAll[2]:null)+", NDCG="+(eGCountAll>0?scoreForAll[3]:null));
//			System.out.println("Results(all@"+topk+"):\tF-measure="+scoreForAll[2]+", MAP="+scoreForAll[3]);
		}
	}
	
	/**
	 * modified to 175
	 * @author qxliu Mar 26, 2019 1:49:50 PM
	 * 
	 * avg PRF,MAP for top5, top10 on each of the datasets
	 * @param topk
	 * @param ds
	 * @return
	 * @author qxliu Aug 1, 2017 3:53:56 PM
	 */
	private static ThreeTuple<double[], Integer, Integer> getScores(Topk topk, Dataset ds){		
		double[] dsAvg = {0,0,0,0};//PRF MAP
		int eFCount = 0;//num of entities that has _topk.nt files
		int eGCount = 0;//num of entities that has _rank.nt files
		
		File goldDsFolder = new File(benchmarkDir+"/"+ds+"_data/");
//		System.out.println("goldDsFolder:"+goldDsFolder.exists()+"\t"+goldDsFolder.getAbsolutePath());
		for(File eidFolder : goldDsFolder.listFiles()){
			if(!eidFolder.isDirectory()) continue;
			int eid = Integer.valueOf(eidFolder.getName());
			List<List<Triple>> goldSummaries = getGoldSummaries(eid, topk, eidFolder.getAbsolutePath());
			//1. for PRF
			File algoEDir = new File(algosummDir+"/"+ds+"/"+eid+"/");
//			System.out.println("algoEDir:"+algoEDir.exists()+"\t"+algoEDir.getAbsolutePath());
			if(!algoEDir.exists()) continue;//=== if no folder for this entity, jump over
			List<Triple> algoSumm = getAlgoSummaries(eid, topk.toString(), algoEDir.getAbsolutePath());
			if(algoSumm!=null){
				eFCount++;
				double[] avgPRF = getAvgPRF(goldSummaries, algoSumm);//
				for(int i=0; i<3; i++){
					dsAvg[i]+= avgPRF[i];
				}
			}
			//2. for MAP
			List<Triple> algoRank = getAlgoSummaries(eid, "rank_"+topk.toString(), algoEDir.getAbsolutePath());//(for tunnable algo, use "rank_topk.nt" as name;
			if(algoRank!=null){
				eGCount++;
//				double avgMAP = (algoRank==null)?0:getAvgMAP(goldSummaries, algoRank);//for v1.1
				double avgGNDCG = (algoRank==null)?0:getGradedNDCG(goldSummaries, algoRank);//for v1.2
				dsAvg[3] += avgGNDCG;
			}
		}
		
		int eNum = eNumMap.get(ds);
		for(int i=0; i<4; i++) dsAvg[i]/= eNum;	
		return new ThreeTuple<>(dsAvg, eFCount, eGCount);
	}
	/**
	 * avg PRF,MAP for top5, top10 on each of the datasets
	 * @param topk
	 * @param ds
	 * @return
	 * @author qxliu Aug 1, 2017 3:53:56 PM
	 */
	@Deprecated
	private static ThreeTuple<double[], Integer, Integer> getScores_old140(Topk topk, Dataset ds){		
		int startEid = ds.equals(Dataset.dbpedia)?1:101;
		int endEid = ds.equals(Dataset.dbpedia)?100:140;
		double[] dsAvg = {0,0,0,0};//PRF MAP
		int eFCount = 0;//num of entities that has _topk.nt files
		int eMCount = 0;//num of entities that has _rank.nt files
		for(int eid=startEid; eid<=endEid; eid++){//dbp entities
			//0. get ground-truth summaries
			File goldEDir = new File(benchmarkDir+"/"+ds+"/"+eid+"/");
			List<List<Triple>> goldSummaries = getGoldSummaries(eid, topk, goldEDir.getAbsolutePath());
			//1. for PRF
			File algoEDir = new File(algosummDir+"/"+ds+"/"+eid+"/");
			if(!algoEDir.exists()) continue;//=== if no folder for this entity, jump over
			List<Triple> algoSumm = getAlgoSummaries(eid, topk.toString(), algoEDir.getAbsolutePath());
			if(algoSumm!=null){
				eFCount++;
				double[] avgPRF = getAvgPRF(goldSummaries, algoSumm);//
				for(int i=0; i<3; i++){
					dsAvg[i]+= avgPRF[i];
				}
			}
			//2. for MAP
			List<Triple> algoRank = getAlgoSummaries(eid, "rank", algoEDir.getAbsolutePath());
			if(algoRank!=null){
				eMCount++;
				double avgMAP = (algoRank==null)?0:getAvgMAP(goldSummaries, algoRank);
				dsAvg[3] += avgMAP;
			}
		}
		int eNum = eNumMap.get(ds);
		for(int i=0; i<4; i++) dsAvg[i]/= eNum;	
		return new ThreeTuple<>(dsAvg, eFCount, eMCount);
	}
	/**
	 * 
	 * @param eid
	 * @param topk
	 * @param dsDir
	 * @return (should be List and not be Set, otherwise, same summary from different user will be regarded as one summary)
	 * @author qxliu Aug 1, 2017 3:53:01 PM
	 */
	private static List<List<Triple>> getGoldSummaries(int eid, Topk topk, String goldEDirPath){
		List<List<Triple>> goldSummaries = new ArrayList<>();
		for(int u=0; u<6; u++){
			String filePath = goldEDirPath+"/"+eid+"_gold_"+topk+"_"+u+".nt";
			List<Triple> triples = readTriplesFromNT(filePath);
			goldSummaries.add(triples);
		}
		return goldSummaries;
	}
	/**
	 * 
	 * @param eid
	 * @param topk
	 * @param dsDir
	 * @return triples in e.g. ....\ESBM_benchmark\data\dbpedia\1\1_top5/top10/rank.nt
	 * @author qxliu Aug 1, 2017 3:53:06 PM
	 */
	private static List<Triple> getAlgoSummaries(int eid, String topk, String algoEDirPath){
			String filePath = algoEDirPath+"/"+eid+"_"+topk+".nt";//dsDir+"/"+eid+"/"+eid+"_"+topk+".nt";//1_top5.nt
			File file = new File(filePath);
//			System.out.println("algoFile1:"+file.exists()+"\t"+file.getAbsolutePath());
			if(topk.startsWith("rank") && !file.exists()){//not tunnable algo, use "rank.nt" as name; (for tunnable algo, use "rank_topk.nt" as name;
				filePath = algoEDirPath+"/"+eid+"_rank.nt";
				file = new File(filePath);//
//				System.out.println("algoFile2:"+file.exists()+"\t"+file.getAbsolutePath());
				if(!file.exists()){
					return null;
				}
			}	
//			System.out.println("filePath:"+filePath);
			List<Triple> triples = readTriplesFromNT(filePath);
		return triples;
	}
	/**
	 * 
	 * @param goldSummaries
	 * @param algoSumm
	 * @return
	 * @author qxliu Aug 1, 2017 3:53:12 PM
	 */
	private static double[] getAvgPRF(List<List<Triple>> goldSummaries, List<Triple> algoSumm){
		double sumP = 0;
		double sumR = 0; 
		double sumF = 0;
		int uNum = goldSummaries.size();
		if(algoSumm!=null){
			for(List<Triple> goldSum : goldSummaries){
				double[] prf = AlgoMeasures.getPRF(goldSum, algoSumm);
				sumP += prf[0];
				sumR += prf[1];
				sumF += prf[2];
			}//for
		}
		double[] avg = {sumP/uNum, sumR/uNum, sumF/uNum};
		return avg;
	}
	/**
	 * 
	 * @param goldSummaries
	 * @param algoSumm
	 * @return
	 * @author qxliu Aug 1, 2017 4:12:30 PM
	 */
	private static double getAvgMAP(List<List<Triple>> goldSummaries, List<Triple> algoSumm){
		double sumF = 0;
		int uNum = goldSummaries.size();
		for(List<Triple> goldSum : goldSummaries){
			double MAP = AlgoMeasures.getMAP(goldSum, algoSumm);
			sumF += MAP;
		}
		return sumF/uNum;
	}
	/**
	 * 
	 * @param goldSummaries
	 * @param algoRank
	 * @return
	 * @author qxliu 2019年9月6日 上午10:56:49
	 */
	private static double getGradedNDCG(List<List<Triple>> goldSummaries, List<Triple> algoRank){
		Map<Triple, Integer> tripleGrade = new HashMap<>();
		for(List<Triple> goldSum : goldSummaries){
			for(Triple t : goldSum){
				tripleGrade.compute(t, (k,v)->(v==null)?1:v+1);
			}
		}

		List<Integer> gradeList = new ArrayList<>(tripleGrade.values());
		Collections.sort(gradeList, Collections.reverseOrder()); //sort by desc to get idea grade list
		
		double dcg = 0;
		double idcg = 0;
		int maxRankPos = algoRank.size();
		int maxIdealPos = gradeList.size();
		for(int pos=1; pos<=maxRankPos; pos++){
			Triple t = algoRank.get(pos-1);
			Integer rel = tripleGrade.get(t);
			rel = (rel==null)?0:rel;
			double dcgItem = (rel)/(Math.log(pos+1)/Math.log(2));
			dcg += dcgItem;

			if(pos<=maxIdealPos){//if has gold 
				Integer ideaRel = gradeList.get(pos-1);
				idcg += (ideaRel)/(Math.log(pos+1)/Math.log(2));
			}
		}
		double ndcg = dcg/idcg;
		return ndcg;
	}
	/**
	 * read triples from NT files retaining the order
	 * @return
	 * @author qxliu Aug 1, 2017 3:01:47 PM
	 */
	private static List<Triple> readTriplesFromNT(String ntFileName){
		List<Triple> tripleList = new ArrayList<>();
		
//		final String filename = "D:/1_desc.nt";//"data.ttl";

        // Create a PipedRDFStream to accept input and a PipedRDFIterator to
        // consume it
        // You can optionally supply a buffer size here for the
        // PipedRDFIterator, see the documentation for details about recommended
        // buffer sizes
        PipedRDFIterator<Triple> iter = new PipedRDFIterator<>();
        final PipedRDFStream<Triple> inputStream = new PipedTriplesStream(iter);

        // PipedRDFStream and PipedRDFIterator need to be on different threads
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Create a runnable for our parser thread
        Runnable parser = new Runnable() {

            @Override
            public void run() {
                RDFParser.source(ntFileName).lang(Lang.NT).parse(inputStream);
            }
        };

        // Start the parser on another thread
        executor.submit(parser);

        // We will consume the input on the main thread here

        // We can now iterate over data as it is parsed, parsing only runs as
        // far ahead of our consumption as the buffer size allows
        while (iter.hasNext()) {
            Triple next = iter.next();
            tripleList.add(next);
            // Do something with each triple
        }
        iter.close();
        executor.shutdown();
        
        return tripleList;
	}
	/**
	 * 
	 * @param fileName
	 * @return
	 * @author qxliu Aug 11, 2017 5:48:21 PM
	 */
	private static int lineCount(String fileName){
		File file = new File(fileName);
		int lineCount = 0;
		try {
			Scanner scanner = new Scanner(file, "UTF-8");
			while(scanner.hasNextLine()){
				String line = scanner.nextLine();
				if(line.trim().length()>0){
					lineCount++;
				}
			}
			scanner.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return lineCount;
	}
}
